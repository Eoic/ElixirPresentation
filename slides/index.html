<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title> Concurrent programming with Elixir </title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css">
		<link rel="stylesheet" href="plugin/highlight/an-old-hope.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Title. -->
				<section
					data-background-color="#220e45"
					data-background-image="/images/elixir.png"
					data-background-size="30% auto"
					data-background-position="85% 50%"
					data-background-opacity="0.25"
				>
					<h2 style="max-width: 75%"> Concurrent programming in Elixir </h2>
					<p> It's <s style="text-decoration-thickness: 3px;">turtles</s> processes all the way down. </p>
				</section>

				<!-- About Elixir. -->
				<section>
					<h2> What is Elixir? </h2>
					<ul>
						<li> <b>Dynamic</b>, functional programming language. </li>
						<li> Aimed at developing large-scale, fault-tolerant systems. </li>
						<li> Runs on the <b>Erlang VM</b> (BEAM). </li>
						<li> <b>Functions</b> are grouped into modules. </li>
						<li> A <b>module</b> is the smallest unit of compilation. </li>
					</ul>
				</section>

				<!-- Elixir features. -->
				<section>
					<h2> Features </h2>
					<ul>
						<li> Data immutability, <b>pattern matching</b>, higher order functions. </li>
						<li> <b>Metaprogramming</b> through macros (for building DSLs). </li>
						<li> Ad-hoc polymorphism (via protocols). </li>
						<li> Offers high-level <b>abstractions</b> for implementing concurrency easily. </li>
					</ul>
				</section>

				<!-- Concurrency 1. -->
				<section>
					<h3> Concurrency </h3>
					<ul>
						<li> Erlang VM runs on a single <b>OS process</b>. </li>
						<li> The <b>unit of concurrency is an </b> Erlang process. </li>
						<li> Processes are <b>lightweight</b> - few μs to create, under a few KB in size. </li>
						<li> Erlang VM creates <b>schedulers</b> to manage process execution. </li>
						<li> Schedulers allocate time-slots for each process, usually <b>≤ 1 ms</b>. </li>
					</ul>
				</section>

				<!-- BEAM concurrency 1. -->
				<section>
					<h3> Concurrency model </h3>
					<img style="width: 100%; height: auto;" src="./images/beam.svg">
				</section>

				<!-- <section>
					<h3> Why processes? </h3>
					<ul>
						<li> Can take advantage of all available CPU resources. </li>
						<li> Isolated from each other, which localizes the effects of run-time errors. </li>
					</ul>
				</section> -->

				<!-- Process fundamentals. -->
				<section>
					<h3> Process fundamentals (1/2) </h3>
					<ul>
						<li> Processes communicate through <b>asynchronous messages</b>. </li>
						<li> Processes <b>do not share memory</b> - message data is deep copied. </li>
						<li> Messages are stored in the <b>"mailbox"</b> of the receiver process and read in FIFO order. </li>
						<li> Processes are sequantial and consume messages one by one. </li>
						<li> In theory, single BEAM instance can handle up to <b>134 million</b> concurrent processes. </li>
					</ul>
				</section>

				<section>
					<h3> Process fundamentals (2/2) </h3>
					<ul>
						<li> Garbage collection takes place at a process level. </li>
						<li> Context switching happens frequently, so whatever th eprocess does, it will not block the entire system. </li>
					</ul>
				</section>

				<!-- Server process - about. -->
				<section>
					<h2> Server process </h2>
					<ul>
						<li> Run an infinite loop in a separate process. </li>
						<li> Maintain the process state through <b>tail call recursion</b>. </li>
						<li> React to <b>sync</b> and <b>async</b> messages. </li>
						<li> Send a response back to the caller. </li>
						<li> Can roll your own, but Elixir offers abstractions such as <b><code>GenServer</code></b>.</li>
					</ul>
				</section>

				<!-- Server process - code -->
				<section class="r-stretch">
					<h2> Server process (2/2) </h2>
					<pre class="r-stretch" style="font-size: 13px; min-height: 100%;">
						<code data-line-numbers class="hljs language-elixir" data-trim>
							defmodule DatabaseServer do
								def start, do: spawn(&loop/0)

								def run_async(server_pid, query) do
									send(server_pid, {:run_query, self(), query})
								end

								def get_result() do
									receive do
										{:query_result, result} -> result
									end
								end

								defp loop do
									receive do
										{:run_query, caller, query} ->
											result = run_query(query)
											send(caller, {:query_result, result})
									end

									loop()
								end

								defp run_query(query) do
									Process.sleep(2000)
									"#{query} result"
								end
							end

							server_pid = DatabaseServer.start()
							DatabaseServer.run_async(server_pid, "Query #1")
							DatabaseServer.get_result()
						</code>
					</pre>
				</section>

				<!-- Registered processes -->
				 <section>
					<h2> Registered processes </h2>
					<ul>
						<li> A process can be given a local name. </li>
						<li> A name must be an atom, and unique within the BEAM instance. </li>
						<li> TODO: Add code example. </li>
					</ul>
				 </section>

				 <section>
					<h2> OTP behaviours </h2>
					<ul>
						<li> OTP is a collection of middleware, patterns, libraries, tools, and protocols that are an integral part of Erlang. </li>
						<li> <b>Generic code</b> that implements the common pattern (e.g. server process). </li>
						<li> Accepts the <b>callback module</b> needs to implement contract functions </li>
						<li> Examples are <code><b>GenServer</b></code>, <code><b>Agent</b></code>, <code><b>Task</b></code>, <code><b>Supervisor</b></code>, <code><b>DynamicSupervisor</b></code>, etc.</li>
					</ul>
				 </section>

				 <!-- Gen server -->
				 <section>
					<h2> GenServer </h2>
					<ul>
						<li> An abstraction for implementing server processes. </li>
						<li> Supports sync (call) and async (cast) operations.
						<li> OTP compatible server process behavior. </li>
						<li> Customizable timeouts for call requests. </li>
					</ul>
				 </section>

				 <section>
					<h2> GenServer example </h2>
					...
				 </section>

				<!-- Registered processes -->
				<section>
					<h2> Fault tolerance </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<!-- Process links -->
				<section>
					<h2> Process links </h2>
					<ul>
						<li> A basic crash detection mechanism. </li>
						<li> Links are like bidirectional comminication channels. </li>
						<li> When process terminates abnormally, other process terminates as well. </li>
					</ul>
					<code>
						spawn(fn ->
							spawn_link(fn ->
								Process.sleep(3000)
								IO.puts("Process #2 finished.")
							end)

							raise("Process #1 raised an error.")
						end)
					</code>
				</section>

				<!-- Trraps -->
				<section>
					<h2> Traps </h2>
					<ul>
						<li> Process can trap exits of the child process. </li>
						<li> Trapped exits are pushed to the process mailbox. </li>
					</ul>

					<code>
						
						Process.flag(:trap_exit, true)
					</code>
				</section>

				<!-- Trraps -->
				<section>
					<h2> Monitors </h2>
					<ul>
						<li> Unidirectional process linking. </li>
						<li> The observer process won't crash - the message about the exit is pushed to the mailbox. </li>
					</ul>
				</section>

				<!-- Supervisors. -->
				<section>
					<h2> Supervisors </h2>
					<blockquote style="width: 100%; padding: 0.5em 1em; border-radius: 6px;">
						"A once in a billion bug will show up every 3 hours in a system doing 100,000 requests per second." 
					</blockquote>
					<ul>
						<li>Monitors child processes - <b>workers</b> and other <b>supervisors</b>.</li>
						<li> If the process terminates, supervisor will perform corrective actions (e.g. restart). </li>
						<li> Uses links, monitors and exit traps. </li>
						<li>Applies restart strategy to roll back the system to the <b>stable state</b>. </li>
					</ul>
				</section>

				<section>
					<h2> Supervisors example </h2>
					<pre class="r-stretch">
						<code data-line-numbers class="hljs language-elixir" data-trim>
						> Supervisor.start_link([Todo.Server], strategy: :one_for_one)
						# "Starting TODO server."

						> server_pid = Process.whereis(Todo.Server)
						# "PID<0.159.0>"

						> Process.exit(server_pid, :kill)
						# "true"
						# "Starting TODO server."

						> server_pid = Process.whereis(Todo.Server)
						# "PID<0.164.0>"

						> Process.exit(server_pid, :kill)
						# "true"
  				# "Starting TODO server."
					</code>
					</pre>
				</section>

				<section>
					<h2> Via tuples </h2>
					<ul>
						<li> Supervisors need a way to discover processes. </li>
						<li> The problem: process PIDs are short lived. </li>
					</ul>
				</section>

				<!-- Child spec. -->
				<section>
					<h2> Children specifications </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<!-- Crashing. -->
				<section>
					<h2> "Let it crash" </h2>
					<blockquote style="width: 100%; padding: 0.5em 1em; border-radius: 6px;"> "Have you tried turning it off and on again?" </blockquote>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<!-- Supervisor - restart policy. -->
				<section>
					<h2> Restart strategy (1/2) </h2>
					<div class="flex-col-inner">
						<div>
							<img src="./images/restart_policy.png" style="width: 100%; height: auto; border-radius: 0.5em;">
							<small>(Source: <a href="https://adoptingerlang.org/docs/development/supervision_trees/">https://adoptingerlang.org/docs/development/supervision_trees/</a>)</small>
						</div>
					</div>
				</section>

				<section>
					<h2> Restart strategy (2/2) </h2>
					<blockquote style="width: 100%; padding: 0.5em 1em; border-radius: 6px;">
						"...the supervisor just gives up on your code, shuts it down then kills itself to never return (that's how bad it is)."
						<p style="color: #909090">&mdash;Learn You Some Erlang, <cite>Supervisors</cite></p>
					</blockquote>
					<ul>
						<li> Processes can be permanent, temporary, and transient. </li>
						<li> Only a predefined number of restarts are allowed in a time frame. </li>
					</ul>
				</section>

				<!-- Supervision trees. -->
				<section>
					<h2> Supervision trees </h2>
					<div class="flex-col-inner">
						<div>
							<img style="width: 100%; height: auto; border-radius: 0.5em;" src="./images/suptree.png">
							<small style="text-align: center;">(Source: <a href="https://adoptingerlang.org/docs/development/supervision_trees/">https://adoptingerlang.org/docs/development/supervision_trees/</a>)</small>
						</div>
					</div>
				</section>

				<!-- Child spec. -->
				<section>
					<h2> Tasks </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<!-- Child spec. -->
				<section>
					<h2> Agents </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<!-- Child spec. -->
				<section>
					<h2> ETS tables </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<section>
					<h2> Summary </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<section style="height: 100%;">
					<div style="display: flex !important; justify-content: center; align-items: center; height: 100%;">
						<h1>Q&A</h1>
					</div>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="dist/socket.io.min.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				center: false,
				slideNumber: true,
				transition: 'slide',
				plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
			}).then(() => {
				const socket = io("ws://localhost:9001");

				socket.on('connect', () => {
					socket.emit('register', { role: 'follower' });
				});

				socket.on('action', ({ action }) => {
					switch (action) {
						case 'left':
							Reveal.left();
							break;
						case 'right':
							Reveal.right();
							break;
						case 'up':
							Reveal.up();
							break;
						case 'down':
							Reveal.down();
							break;
						case 'overview-off':
							Reveal.toggleOverview(false);
							break;
						case 'overview-on':
							Reveal.toggleOverview(true);
							break;
						default: {
							console.log('Unknown action:', action);
						}
					}
				});
			});
		</script>
	</body>
</html>
