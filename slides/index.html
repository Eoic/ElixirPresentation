<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title> Concurrent programming with Elixir </title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css">
		<link rel="stylesheet" href="plugin/highlight/an-old-hope.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Title. -->
				<section
					data-background-color="#220e45"
					data-background-image="/images/elixir.png"
					data-background-size="30% auto"
					data-background-position="85% 50%"
					data-background-opacity="0.25"
				>
					<h2> Concurrent programming with Elixir </h2>
					<p> "..." </p>
				</section>

				<!-- About Elixir. -->
				<section>
					<h2> What is Elixir? </h2>
					<ul>
						<li> Dynamic, functional programming language. </li>
						<li> Aimed for developing large-scale, fault-tolerant systems. </li>
						<li> Designed to be practical, with focus on developer productivity (Ruby-like syntax). </li>
						<li> Runs on the Erlang VM (BEAM). </li>
						<li> Created as an R&D project at Platformatec by José Valim in 2012. </li>
					</ul>
				</section>

				<!-- Elixir features. -->
				<section>
					<h2> Features </h2>
					<ul>
						<li> Data immutability, pattern matching, pure and high order functions. </li>
						<li> Metaprogramming through macros. </li>
						<li> Polymorphism for deciding behavior at runtime. </li>
						<li> Compatibility with Erlang </li>
					</ul>
				</section>

				<!-- Concurrency 1. -->
				<section>
					<h3> Concurrency </h3>
					<ul>
						<li> Erlang VM runs on a single <b>OS process</b>. </li>
						<li> The <b>unit of concurrency is an </b> Erlang process. </li>
						<li> Processes are <b>lightweight</b> - few μs to create, under a few KB in size. </li>
						<li> Erlang VM creates <b>schedulers</b> to manage process execution. </li>
						<li> Schedulers allocate time-slots for each process, usually <b>≤ 1 ms</b>. </li>
					</ul>
				</section>

				<!-- Concurrency 2. -->
				<section>
					<h3> Processes </h3>
					<ul>
						<li> Processes communicate through <b>asynchronous messages</b>. </li>
						<li> Processes <b>do not share memory</b> - message data is deep copied. </li>
						<li> Messages are stored in the <b>"mailbox"</b> of the receiver process and read in FIFO order. </li>
						<li> In theory, single BEAM instance can handle up to <b>134 million</b> concurrent processes. </li>
					</ul>
				</section>

				<!-- BEAM concurrency 1. -->
				<section>
					<h3> Concurrency model (1/2) </h3>
					<img style="width: 100%; height: auto;" src="./images/beam.svg">
				</section>

				<!-- BEAM concurrency 2. -->


				<!-- Server process - about. -->
				<section>
					<h2> Server process (1/2)</h2>
					<ul>
						<li> Run an infinite loop in a separate process. </li>
						<li> Maintain the process state through <b>tail call recursion</b>. </li>
						<li> React to <b>sync</b> and <b>async</b> messages. </li>
						<li> Send a response back to the caller. </li>
						<li> Can roll your own, but Elixir offers abstractions such as <b><code>GenServer</code></b>.</li>
					</ul>
				</section>

				<!-- Server process - code -->
				<section class="r-stretch">
					<h2> Server process (2/2) </h2>
					<pre class="r-stretch" style="font-size: 13px; min-height: 100%;">
						<code data-line-numbers class="hljs language-elixir" data-trim>
							defmodule DatabaseServer do
								def start, do: spawn(&loop/0)

								def run_async(server_pid, query) do
									send(server_pid, {:run_query, self(), query})
								end

								def get_result() do
									receive do
										{:query_result, result} -> result
									end
								end

								defp loop do
									receive do
										{:run_query, caller, query} ->
											result = run_query(query)
											send(caller, {:query_result, result})
									end

									loop()
								end

								defp run_query(query) do
									Process.sleep(2000)
									"#{query} result"
								end
							end

							server_pid = DatabaseServer.start()
							DatabaseServer.run_async(server_pid, "Query #1")
							DatabaseServer.get_result()
						</code>
					</pre>
				</section>

				<!-- Supervisors. -->
				<section>
					<h2> Supervisors </h2>
					<blockquote style="width: 100%; padding: 0.5em 1em; border-radius: 6px;"> "Have you tried turning it off and on again?" </blockquote>
					<ul>
						<li>Monitors child processes - <b>workers</b> and other <b>supervisors</b>.</li>
						<li>Applies restart strategy to roll back the system to the <b>stable state</b>. </li>
						<li>"A once in a billion bug will show up every 3 hours in a system doing 100,000 requests per second." </li>
					</ul>
				</section>

				<!-- Supervisor - restart policy. -->
				<section>
					<h2> Restart strategy (1/2) </h2>
					<div class="flex-col-inner">
						<div>
							<img src="./images/restart_policy.png" style="width: 100%; height: auto; border-radius: 0.5em;">
							<small>(Source: <a href="https://adoptingerlang.org/docs/development/supervision_trees/">https://adoptingerlang.org/docs/development/supervision_trees/</a>)</small>
						</div>
					</div>
				</section>

				<section>
					<h2> Restart strategy (2/2) </h2>
					<blockquote style="width: 100%; padding: 0.5em 1em; border-radius: 6px;">
						"...the supervisor just gives up on your code, shuts it down then kills itself to never return (that's how bad it is)."
						<p style="color: #909090">&mdash;Learn You Some Erlang, <cite>Supervisors</cite></p>
					</blockquote>
					<ul>
						<li> Processes can be permanent, temporary, and transient. </li>
						<li> Only a predefined number of restarts are allowed in a time frame. </li>
					</ul>
				</section>

				<!-- Supervision trees. -->
				<section>
					<h2> Supervision trees </h2>
					<div class="flex-col-inner">
						<div>
							<img style="width: 100%; height: auto; border-radius: 0.5em;" src="./images/suptree.png">
							<small style="text-align: center;">(Source: <a href="https://adoptingerlang.org/docs/development/supervision_trees/">https://adoptingerlang.org/docs/development/supervision_trees/</a>)</small>
						</div>
					</div>
				</section>

				<section>
					<h2> Summary </h2>
					<ul>
						<li> ... </li>
					</ul>
				</section>

				<section style="height: 100%;">
					<div style="display: flex !important; justify-content: center; align-items: center; height: 100%;">
						<h1>Q&A</h1>
					</div>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="dist/socket.io.min.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				center: false,
				slideNumber: true,
				transition: 'slide',
				plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
			}).then(() => {
				const socket = io("ws://localhost:9001");

				socket.on('connect', () => {
					socket.emit('register', { role: 'follower' });
				});

				socket.on('action', ({ action }) => {
					switch (action) {
						case 'left':
							Reveal.left();
							break;
						case 'right':
							Reveal.right();
							break;
						case 'up':
							Reveal.up();
							break;
						case 'down':
							Reveal.down();
							break;
						case 'overview-off':
							Reveal.toggleOverview(false);
							break;
						case 'overview-on':
							Reveal.toggleOverview(true);
							break;
						default: {
							console.log('Unknown action:', action);
						}
					}
				});
			});
		</script>
	</body>
</html>
